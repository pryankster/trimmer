//
// Trimmer Framework for Unity
// https://sttz.ch/trimmer
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using UnityEditor;
using UnityEngine;

namespace sttz.Trimmer.Editor
{

/// <summary>
/// How a distribution should handle building its profiles.
/// </summary>
public enum DistroBuildMode
{
    /// <summary>
    /// Don't build at all, generate an error if builds are missing.
    /// </summary>
    None,
    /// <summary>
    /// Only build the profile/targets that are missing.
    /// </summary>
    BuildMissing,
    /// <summary>
    /// (Re-)build all profile/targets.
    /// </summary>
    BuildAll,
}

/// <summary>
/// Base class for distributions.
/// </summary>
/// <remarks>
/// Distributions take the builds generated by one or more Build Profiles and
/// process them in different ways, e.g.
/// * <see cref="ItchDistro"/>: Upload builds to itch.io
/// * <see cref="MASDistro"/>: Process a mac build for the Mac App Store (no automatic upload)
/// * <see cref="SteamDistro"/>: Upload builds to Steam
/// * <see cref="UploadDistro"/>: Zip and Upload builds to a FTP server
/// * <see cref="ZipDistro"/>: Zip builds
/// 
/// There are also more generic distros:
/// * <see cref="ScriptDistro"/>: Call a script with the build path
/// 
/// To create a distro, select the type you want from Create » Trimmer » Distro in the
/// Project window's Create menu.
/// 
/// Note that while a distro is running, reloading of scripts is locked, as the
/// assembly reload would abort the distribution.
/// </remarks>
public abstract class DistroBase : BatchItem
{
    [MenuItem("Assets/Create/Trimmer/Distributions:", false, 99)]
    [MenuItem("Assets/Create/Trimmer/Distributions:", true)]
    static bool Dummy() { return false; }

    /// <summary>
    /// Process the builds of these Build Profiles.
    /// </summary>
    [HideInInspector] public List<BuildProfile> builds;

    /// <summary>
    /// Structure used to represent a set of builds.
    /// </summary>
    public struct BuildPath
    {
        public BuildProfile profile;
        public BuildTarget target;
        public string path;

        public BuildPath(BuildProfile profile, BuildTarget target, string path)
        {
            this.profile = profile;
            this.target = target;
            this.path = path;
        }
    }

    /// <summary>
    /// Check wether there are existing builds for all build target in all linked Build Profiles.
    /// </summary>
    public virtual bool HasAllBuilds()
    {
        foreach (var profile in builds) {
            if (profile == null) continue;
            foreach (var target in profile.BuildTargets) {
                var path = profile.GetLastBuildPath(target);
                if (string.IsNullOrEmpty(path) || (!File.Exists(path) && !Directory.Exists(path))) {
                    return false;
                }
            }
        }

        return true;
    }

    /// <summary>
    /// Get the paths to all existing builds for all build target in all linked Build Profiles.
    /// </summary>
    public virtual IEnumerable<BuildPath> GetBuildPaths()
    {
        var paths = new Dictionary<BuildTarget, BuildPath>();
        foreach (var profile in builds) {
            if (profile == null) continue;
            foreach (var target in profile.BuildTargets) {
                var path = profile.GetLastBuildPath(target);
                if (string.IsNullOrEmpty(path) || (!File.Exists(path) && !Directory.Exists(path))) {
                    paths[target] = new BuildPath(profile, target, null);
                } else {
                    paths[target] = new BuildPath(profile, target, path);
                }
            }
        }
        return paths.Values;
    }

    /// <summary>
    /// Process the builds of the linked Build Profiles and build the
    /// targets where no build exists.
    /// </summary>
    /// <param name="buildMode">Build mode to use</param>
    public void Distribute(DistroBuildMode buildMode = DistroBuildMode.BuildMissing, IBuildsCompleteListener onComplete = null)
    {
        var jobs = new List<BuildRunner.Job>();
        var willBuild = AddBuildJobs(buildMode, jobs);
        jobs.Add(new BuildRunner.Job(this));

        var runner = ScriptableObject.CreateInstance<BuildRunner>();
        runner.Run(jobs.ToArray(), onComplete, willBuild && TrimmerPrefs.RestoreActiveBuildTarget, context: this);
    }

    /// <summary>
    /// Run the distribution as an async task,
    /// since async tasks can't survive domain reloads,
    /// this method cannot build and will error if any builds are missing.
    /// </summary>
    public async Task DistributeWithoutBuilding(TaskToken task = default)
    {
        var removeProgressTask = false;
        if (task.taskId == 0) {
            // Set up default cancelable progress task if none is given
            removeProgressTask = true;

            task.taskId = Progress.Start(name);

            var source = new CancellationTokenSource();
            task.cancellation = source.Token;

            Progress.RegisterCancelCallback(task.taskId, () => {
                source.Cancel();
                return true;
            });
        }

        try {
            // Prevent domain reloads from stopping the distribution
            EditorApplication.LockReloadAssemblies();

            // Check that all builds are present
            var paths = GetBuildPaths();
            if (!paths.Any())
                throw new Exception(name + ": Distribution has no targets in any of its profiles");

            var missingBuilds = false;
            foreach (var path in paths) {
                if (path.path == null) {
                    Debug.LogError(name + ": Missing build for target '" + path.target + "' of profile '" + path.profile + "'");
                    missingBuilds = true;
                }
            }
            if (missingBuilds)
                throw new Exception($"{name}: Missing builds");

            // Run distribution
            await RunDistribute(paths, task);
        } finally {
            EditorApplication.UnlockReloadAssemblies();

            if (removeProgressTask) {
                task.Remove();
            }
        }
    }

    /// <summary>
    /// Build the profile's targets with the given build mode.
    /// Does not run the actual distribution.
    /// </summary>
    /// <param name="buildMode">Build mode to use (must not be <see cref="DistroBuildMode.None"/>)</param>
    /// <param name="onComplete">Listener that will be called when the builds are complete</param>
    public void Build(DistroBuildMode buildMode = DistroBuildMode.BuildAll, IBuildsCompleteListener onComplete = null)
    {
        var jobs = new List<BuildRunner.Job>();
        AddBuildJobs(buildMode, jobs);

        var runner = ScriptableObject.CreateInstance<BuildRunner>();
        runner.Run(jobs.ToArray(), onComplete, TrimmerPrefs.RestoreActiveBuildTarget, context: this);
    }

    /// <summary>
    /// Compile the necessary build jobs.
    /// </summary>
    public bool AddBuildJobs(DistroBuildMode buildMode, List<BuildRunner.Job> jobs)
    {
        if (buildMode == DistroBuildMode.None)
            return false;

        var willBuild = false;
        foreach (var profile in builds) {
            if (profile == null) continue;
            foreach (var target in profile.BuildTargets) {
                var path = profile.GetLastBuildPath(target);
                if (buildMode == DistroBuildMode.BuildAll 
                        || string.IsNullOrEmpty(path) 
                        || (!File.Exists(path) && !Directory.Exists(path))) {
                    jobs.Add(new BuildRunner.Job(profile, target));
                    willBuild = true;
                }
            }
        }

        return willBuild;
    }

    /// <summary>
    /// Subroutine to override in subclasses to do the actual processing.
    /// </summary>
    /// <param name="buildPaths">Build paths of the linked Build Profiles</param>
    /// <param name="task">Task token for reporting progress and cancellation</param>
    protected virtual Task RunDistribute(IEnumerable<BuildPath> buildPaths, TaskToken task)
    {
        return Task.CompletedTask;
    }

    // -------- Execute Script --------

    /// <summary>
    /// Arguments for <see cref="Execute"/>.
    /// </summary>
    protected struct ExecutionArgs
    {
        /// <summary>
        /// The process start info, including path and arguments.
        /// </summary>
        public System.Diagnostics.ProcessStartInfo startInfo;
        /// <summary>
        /// Input to be sent to the script's stdio at the beginning.
        /// Whenever possible, use this for passwords.
        /// </summary>
        public string input;
        /// <summary>
        /// Callback for script's stdout.
        /// </summary>
        public Action<string> onOutput;
        /// <summary>
        /// Callback for script's stderr.
        /// </summary>
        public Action<string> onError;
        /// <summary>
        /// Do not throw exception on non-zero script exit codes.
        /// </summary>
        public bool silentError;

        public ExecutionArgs(string path, string args)
        {
            this.startInfo = new System.Diagnostics.ProcessStartInfo(path, args);
            this.input = null;
            this.onOutput = null;
            this.onError = null;
            this.silentError = false;
        }
    }

    /// <summary>
    /// Async wrapper for OptionHelper.RunScriptAsync.
    /// </summary>
    protected async Task<int> Execute(ExecutionArgs args, TaskToken task)
    {
        var outputBuilder = new StringBuilder();
        var errorBuilder = new StringBuilder();
        int? exitcode = null;
        var terminator = OptionHelper.RunScriptAsnyc(
            args.startInfo, args.input,
            (output) => {
                outputBuilder.AppendLine(output);
                args.onOutput?.Invoke(output);
            },
            (error) => {
                errorBuilder.AppendLine(error);
                args.onError?.Invoke(error);
            },
            (code) => {
                exitcode = code;
            }
        );

        while (exitcode == null) {
            if (task.cancellation.IsCancellationRequested) {
                terminator(true);
                task.ThrowIfCancellationRequested();
            }
            await Task.Yield();
        }

        // 137 happens for Kill() and 143 for CloseMainWindow(),
        // which means the script has been canceled
        if (!args.silentError && exitcode != 0 && exitcode != 137 && exitcode != 143) {
            throw new Exception(string.Format(
                "{0}: Failed to execute {1} (code {2}): {3}\nOutput: {4}",
                name, Path.GetFileName(args.startInfo.FileName), exitcode,
                errorBuilder.ToString(), outputBuilder.ToString()
            ));
        }

        return exitcode.Value;
    }
}

}
